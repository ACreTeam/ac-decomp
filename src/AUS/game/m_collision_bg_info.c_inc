// @unused, @fabricated, size mismatch
extern void mCoBG_GetSlopeSlideVector(xyz_t* vec, xyz_t pos) {
    xyz_t normal;
    xyz_t v1;
    f32 vec_len;
    f32 mult;

    mCoBG_GetBgNorm_FromWpos(&normal, pos);
    *vec = normal;
    vec->y *= -1.0f;
    if (vec->x != 0.0f || vec->y != 0.0f || vec->z != 0.0f) {
        mult = 3.0f / sqrtf(SQ(vec->x) + SQ(vec->y) + sqrt(vec->z));

        v1.x = vec->x * mult;
        v1.y = (vec->y * 5.0f) * mult;
        v1.z = vec->z * mult;
        *vec = v1;
    }
}

extern f32 mCoBG_GetBgY_AngleS_FromWpos(s_xyz* ground_angle, xyz_t pos, f32 ground_dist) {
    mCoBG_UnitInfo_c ut_info;
    s_xyz normal_ground_angle;
    f32 normal_y;
    f32 column_y;
    f32 move_y;
    static s_xyz ground_angle0 = { 0, 0, 0 };

    if (ground_angle != NULL) {
        *ground_angle = ground_angle0;
    }

    mCoBG_Wpos2UnitInfo(&ut_info, pos);
    normal_y = mCoBG_GetBGHeight_Normal(&normal_ground_angle, &ut_info);
    column_y = mCoBG_GetBGHeight_Column(&pos, &ut_info);
    mCoBG_GetMoveBgHeight(&move_y, &pos);
    
    if (ground_angle != NULL && normal_y >= column_y && normal_y >= move_y) {
        *ground_angle = normal_ground_angle;
        return normal_y - ground_dist;
    }

    return MAX(MAX(normal_y, column_y), MAX(normal_y, move_y)) - ground_dist;
}

extern f32 mCoBG_GetBgY_OnlyCenter_FromWpos(xyz_t pos, f32 ground_dist) {
    f32 y;
    mCoBG_Collision_u* collision;
    int ux;
    int uz;


    mFI_Wpos2UtNum(&ux, &uz, pos);
    collision = mFI_UtNum2UtCol(ux, uz);
    y = 10.0f * collision->data.center;
    return (y + mFI_UtNum2BaseHeight(ux, uz)) - ground_dist;
}

extern f32 mCoBG_Wpos2BgUtCenterHeight_AddColumn(xyz_t pos) {
    f32 y;
    mCoBG_UnitInfo_c ut_info;
    mCoBG_column_c column;

    mCoBG_Wpos2UnitInfo(&ut_info, pos);
    if (mCoBG_MakeOneColumnCollisionData(NULL, &column, &ut_info, FALSE, NULL, -1, -1)) {
        return column.height;
    }

    y = 10.0f * ut_info.collision->data.center;
    return y + mFI_UtNum2BaseHeight(ut_info.ut_x, ut_info.ut_z);
}

extern f32 mCoBG_GetBgY_OnlyCenter_FromWpos2(xyz_t pos, f32 ground_dist) {
    int ux;
    int uz;

    mFI_Wpos2UtNum(&ux, &uz, pos);
    return (mFI_UtNum2UtKeepH(ux, uz) * 10.0f + mFI_UtNum2BaseHeight(ux, uz)) - ground_dist;
}

extern void mCoBG_GetBgNorm_FromWpos(xyz_t* norm, xyz_t wpos) {
    static xyz_t norm0 = { 0.0f, 0.0f, 0.0f };
    mCoBG_UnitInfo_c ut_info;
    s16 area;

    *norm = norm0; // @unnecessary
    mCoBG_Wpos2UnitInfo(&ut_info, wpos);
    mCoBG_GetUnitArea(&ut_info, &area);

    switch (ut_info.collision->data.slate_flag) {
        case 0:
            if (
                ut_info.collision->data.center != ut_info.collision->data.top_left ||
                ut_info.collision->data.center != ut_info.collision->data.bot_left ||
                ut_info.collision->data.center != ut_info.collision->data.bot_right ||
                ut_info.collision->data.center != ut_info.collision->data.top_right
            ) {
                mCoBG_GetNormTriangle(norm, NULL, ut_info.collision, area);
                norm->x *= 0.1f;
                norm->y *= 0.1f;
                norm->z *= 0.1f;
            } else {
                mCoBG_SetXyz_t(norm, 0.0f, 100.0f, 0.0f);
            }
            break;
        case 1:
            mCoBG_SetXyz_t(norm, 0.0f, 100.0f, 0.0f);
            break;
        default:
            // this is impossible to hit because slate_flag is only 1 bit
            mCoBG_SetXyz_t(norm, 0.0f, 0.0f, 0.0f);
            break;
    }
}

extern int mCoBG_ScrollCheck(xyz_t start, xyz_t end, f32 radius) {
    int ux;
    int uz;
    f32 speed[2];

    speed[0] = end.x - start.x;
    speed[1] = end.z - start.z;

    if (ABS(speed[0]) == 0.0f && ABS(speed[1]) == 0.0f) {
        return FALSE;
    }

    mFI_Wpos2UtNum(&ux, &uz, end);
    mCoBG_MakeSizeUnitInfo(l_crtutInf, ux, uz, 3);
    mCoBG_MakeUnitVector(&l_VecInf, l_crtutInf, 3, mCoBG_CHECK_TYPE_NORMAL, TRUE, TRUE, FALSE);

    {
        f32 startp[2];
        f32 endp[2];
        int count = l_VecInf.unit_count;
        mCoBG_unit_vec_info_c* unit_vec = l_VecInf.unit;
        mCoBG_column_c* column;
        int i;

        startp[0] = start.x;
        startp[1] = start.z;
        endp[0] = end.x;
        endp[1] = end.z;
        for (i = 0; i < count; i++) {
            f32 dist;

            if (mCoBG_RangeCheckLinePoint(unit_vec->start, unit_vec->end, endp) &&
                mCoBG_GetDistPointAndLine2D_Norm(&dist, unit_vec->start, unit_vec->end, unit_vec->normal, endp) &&
                dist <= (radius - 0.1f)) {
                return FALSE;
            }

            if (mCoBG_GetCrossJudge_2Vector(startp, endp, unit_vec->start, unit_vec->end)) {
                return FALSE;
            }

            unit_vec++;
        }

        {
            mCoBG_column_c* col2;
            int count;
            int i;

            column = l_VecInf.column;
            mCoBG_MakeColumnCollisionData(NULL, column, &l_VecInf.col_count, l_crtutInf, 3, TRUE, NULL, -1, -1);
            count = l_VecInf.col_count;
            if (count > 0) {
                col2 = column;
                for (i = 0; i < count; i++) {
                    f32 dx = end.x - col2->pos.x;
                    f32 dz = end.z - col2->pos.z;
                    f32 check_dist = radius + col2->radius;
                    f32 dist = sqrtf(SQ(dx) + SQ(dz));

                    if (dist <= check_dist) {
                        return FALSE;
                    }

                    col2++;
                }
            }
        }
    }

    return TRUE;
}

static u8 l_attribute_action_info[64] = {
    mCoBG_ATR_NPC | mCoBG_ATR_PLACE | mCoBG_PLANT4,
    mCoBG_ATR_NPC | mCoBG_ATR_PLACE | mCoBG_PLANT2,
    mCoBG_ATR_NPC | mCoBG_ATR_PLACE | mCoBG_PLANT0,
    mCoBG_ATR_NPC | mCoBG_ATR_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NPC | mCoBG_ATR_PLACE | mCoBG_PLANT4,
    mCoBG_ATR_NPC | mCoBG_ATR_PLACE | mCoBG_PLANT2,
    mCoBG_ATR_NPC | mCoBG_ATR_PLACE | mCoBG_PLANT0,
    mCoBG_ATR_NPC | mCoBG_ATR_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NPC | mCoBG_ATR_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NPC | mCoBG_ATR_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NPC | mCoBG_ATR_PLACE | mCoBG_PLANT0,
    mCoBG_ATR_NO_NPC | mCoBG_ATR_NO_PLACE | mCoBG_PLANT0,
    mCoBG_ATR_NO_NPC | mCoBG_ATR_NO_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NO_NPC | mCoBG_ATR_NO_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NO_NPC | mCoBG_ATR_NO_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NO_NPC | mCoBG_ATR_NO_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NO_NPC | mCoBG_ATR_NO_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NO_NPC | mCoBG_ATR_NO_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NO_NPC | mCoBG_ATR_NO_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NO_NPC | mCoBG_ATR_NO_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NO_NPC | mCoBG_ATR_NO_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NO_NPC | mCoBG_ATR_NO_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NPC | mCoBG_ATR_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NPC | mCoBG_ATR_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NO_NPC | mCoBG_ATR_NO_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NO_NPC | mCoBG_ATR_PLACE | mCoBG_PLANT0,
    mCoBG_ATR_NO_NPC | mCoBG_ATR_PLACE | mCoBG_PLANT0,
    mCoBG_ATR_NO_NPC | mCoBG_ATR_NO_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NO_NPC | mCoBG_ATR_NO_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NO_NPC | mCoBG_ATR_NO_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NO_NPC | mCoBG_ATR_NO_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NPC | mCoBG_ATR_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NPC | mCoBG_ATR_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NPC | mCoBG_ATR_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NPC | mCoBG_ATR_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NPC | mCoBG_ATR_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NO_NPC | mCoBG_ATR_PLACE | mCoBG_PLANT0,
    mCoBG_ATR_NO_NPC | mCoBG_ATR_NO_PLACE | mCoBG_PLANT0,
    mCoBG_ATR_NO_NPC | mCoBG_ATR_NO_PLACE | mCoBG_PLANT0,
    mCoBG_ATR_NO_NPC | mCoBG_ATR_NO_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NO_NPC | mCoBG_ATR_NO_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NO_NPC | mCoBG_ATR_NO_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NO_NPC | mCoBG_ATR_NO_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NPC | mCoBG_ATR_PLACE | mCoBG_PLANT0,
    mCoBG_ATR_NPC | mCoBG_ATR_PLACE | mCoBG_PLANT0,
    mCoBG_ATR_NPC | mCoBG_ATR_PLACE | mCoBG_PLANT0,
    mCoBG_ATR_NPC | mCoBG_ATR_PLACE | mCoBG_PLANT0,
    mCoBG_ATR_NPC | mCoBG_ATR_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NPC | mCoBG_ATR_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NPC | mCoBG_ATR_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NPC | mCoBG_ATR_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NPC | mCoBG_ATR_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NPC | mCoBG_ATR_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NPC | mCoBG_ATR_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NPC | mCoBG_ATR_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NO_NPC | mCoBG_ATR_NO_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NO_NPC | mCoBG_ATR_NO_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NO_NPC | mCoBG_ATR_NO_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NO_NPC | mCoBG_ATR_NO_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NPC | mCoBG_ATR_PLACE | mCoBG_PLANT0,
    mCoBG_ATR_NPC | mCoBG_ATR_PLACE | mCoBG_PLANT0,
    mCoBG_ATR_NPC | mCoBG_ATR_PLACE | mCoBG_PLANT0,
    mCoBG_ATR_NPC | mCoBG_ATR_NO_PLACE | mCoBG_KILL_PLANT,
    mCoBG_ATR_NPC | mCoBG_ATR_PLACE | mCoBG_PLANT0,
};

static int mCoBG_CheckPlace_OrgAttr(u32 org_attr) {
    return (l_attribute_action_info[org_attr] >> 3) & 1;
}

extern int mCoBG_CheckPlace(xyz_t pos) {
    mCoBG_Collision_u* collision = mFI_GetUnitCol(pos);
    u32 org_attr = collision->data.unit_attribute;

    return mCoBG_CheckPlace_OrgAttr(org_attr);
}

// @unused, @fabricated
extern int mCoBG_UtCheckPlace(int ux, int uz) {
    mCoBG_Collision_u* collision = mFI_UtNum2UtCol(ux, uz);
    u32 org_attr = collision->data.unit_attribute;

    return mCoBG_CheckPlace_OrgAttr(org_attr);
}

extern int mCoBG_Attribute2CheckPlant(u32 attr, const xyz_t* pos) {
    if (mFI_GET_TYPE(mFI_GetFieldId()) == mFI_FIELDTYPE2_FG) {
        u8 info = l_attribute_action_info[attr];
        u8 plant = info & 7;

        if (attr == mCoBG_ATTRIBUTE_63) {
            mCoBG_Collision_u* col;
            u32 new_attr;
            xyz_t new_pos;

            new_pos = *pos;
            new_pos.z +=mFI_UT_WORLDSIZE_Z_F;
            col = mFI_GetUnitCol(new_pos);
            new_attr = col->data.unit_attribute;
            return mCoBG_Attribute2CheckPlant(new_attr, &new_pos);
        } else {
            if (plant != mCoBG_KILL_PLANT) {
                return plant;
            }

            return -1;
        }
    }

    return -1;
}

extern int mCoBG_CheckPlant(xyz_t pos) {
    mCoBG_Collision_u* collision = mFI_GetUnitCol(pos);
    u32 org_attr = collision->data.unit_attribute;

    return mCoBG_Attribute2CheckPlant(org_attr, &pos);
}

// @unused, @fabricated
extern int mCoBG_Unit2CheckNpc(int ux, int uz) {
    mCoBG_Collision_u* collision = mFI_UtNum2UtCol(ux, uz);
    u32 org_attr = collision->data.unit_attribute;

    return mCoBG_Attr2CheckPlaceNpc(org_attr);
}

extern int mCoBG_Wpos2CheckNpc(xyz_t pos) {
    mCoBG_Collision_u* collision = mFI_GetUnitCol(pos);
    u32 org_attr = collision->data.unit_attribute;

    return mCoBG_Attr2CheckPlaceNpc(org_attr);
}

// @unused, @fabricated
extern int mCoBG_Attr2CheckPoorGround(u32 attr) {
    u8 info = l_attribute_action_info[attr];
    u8 plant = info & 7;

    if (plant == mCoBG_KILL_PLANT || plant == mCoBG_PLANT0) {
        return TRUE;
    }

    return FALSE;
}

extern int mCoBG_Attr2CheckPlaceNpc(u32 attr) {
    u8 info = l_attribute_action_info[attr & 0x3F];

    return (info >> 4) & 1;
}

extern int mCoBG_UtNum2BgAttr(int ux, int uz) {
    mCoBG_Collision_u* col = mFI_UtNum2UtCol(ux, uz);

    if (col != NULL) {
        return col->data.unit_attribute;
    }

    return mCoBG_ATTRIBUTE_GRASS0;
}

extern f32 mCoBG_UtNum2UtCenterY(int ux, int uz) {
    f32 pos_x = (f32)ux;
    f32 pos_z = (f32)uz;
    xyz_t pos;

    pos.x = mFI_UT_WORLDSIZE_HALF_X_F + pos_x * mFI_UT_WORLDSIZE_X_F;
    pos.y = 0.0f;
    pos.z = mFI_UT_WORLDSIZE_HALF_Z_F + pos_z * mFI_UT_WORLDSIZE_Z_F;
    if (uz >= (FG_BLOCK_Z_NUM + 1) * UT_Z_NUM) {
        return 40.0f;
    }

    return mCoBG_GetBgY_OnlyCenter_FromWpos(pos, 0.0f);
}

extern f32 mCoBG_UtNum2UtCenterY_Keep(int ux, int uz) {
    f32 pos_x = (f32)ux;
    f32 pos_z = (f32)uz;
    xyz_t pos;

    pos.x = mFI_UT_WORLDSIZE_HALF_X_F + pos_x * mFI_UT_WORLDSIZE_X_F;
    pos.y = 0.0f;
    pos.z = mFI_UT_WORLDSIZE_HALF_Z_F + pos_z * mFI_UT_WORLDSIZE_Z_F;
    return mCoBG_GetBgY_OnlyCenter_FromWpos2(pos, 0.0f);
}

extern u32 mCoBG_Wpos2BgAttribute_Original(xyz_t pos) {
    mCoBG_Collision_u* col = mFI_GetUnitCol(pos);

    return col->data.unit_attribute;
}

static u32 mCoBG_SelectBiggerUnint(u32 a, u32 b) {
    if (a > b) {
        return a;
    } else {
        return b;
    }
}

static u32 mCoBG_SelectSmallerUnint(u32 a, u32 b) {
    if (a < b) {
        return a;
    } else {
        return b;
    }
}

static u32 mCoBG_GetMaxOffset(u32 p0, u32 p1, u32 p2, u32 p3, u32 p4) {
    return mCoBG_SelectBiggerUnint(
        mCoBG_SelectBiggerUnint(mCoBG_SelectBiggerUnint(p0, p1), mCoBG_SelectBiggerUnint(p2, p3)),
        p4
    );
}

static u32 mCoBG_GetMinOffset(u32 p0, u32 p1, u32 p2, u32 p3, u32 p4) {
    return mCoBG_SelectSmallerUnint(
        mCoBG_SelectSmallerUnint(mCoBG_SelectSmallerUnint(p0, p1), mCoBG_SelectSmallerUnint(p2, p3)),
        p4
    );
}

// clang-format off
static mCoBG_Collision_u mCoBG_hole_data[] = {
    { 0, 0, 0, 0, 0, 0, 0 },
    { 0, 1, 2, 0, 0, 2, 0 },
    { 0, 1, 0, 2, 2, 0, 0 },
    { 0, 1, 0, 0, 2, 2, 0 },
    { 0, 1, 2, 2, 0, 0, 0 },
    { 0, 2, 2, 0, 2, 4, 0 },
    { 0, 2, 4, 2, 0, 2, 0 },
    { 0, 2, 0, 2, 4, 2, 0 },
    { 0, 2, 2, 4, 2, 0, 0 },
    { 0, 2, 2, 0, 2, 2, 0 },
    { 0, 2, 2, 2, 0, 2, 0 },
    { 0, 2, 0, 2, 2, 2, 0 },
    { 0, 2, 2, 2, 2, 0, 0 },
    { 0, 0, 0, 0, 0, 2, 0 },
    { 0, 0, 2, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 2, 0, 0 },
    { 0, 0, 0, 2, 0, 0, 0 },
    { 0, 1, 0, 0, 0, 2, 0 },
    { 0, 1, 2, 0, 0, 0, 0 },
    { 0, 1, 0, 0, 2, 0, 0 },
    { 0, 1, 0, 2, 0, 0, 0 },
    { 0, 1, 2, 2, 0, 2, 0 },
    { 0, 1, 2, 0, 2, 2, 0 },
    { 0, 1, 2, 2, 2, 0, 0 },
    { 0, 1, 0, 2, 2, 2, 0 },
};
// clang-format on

extern int mCoBG_GetHoleNumber_ClData(mCoBG_Collision_u* col) {
    mCoBG_Collision_u check_col;
    int i;
    u32 min;
    u32 attr;

    attr = col->data.unit_attribute;
    check_col = *col;
    min = mCoBG_GetMinOffset(col->data.center, col->data.top_left, col->data.bot_left, col->data.bot_right, col->data.top_right);
    check_col.data.center -= min;
    check_col.data.bot_right -= min;
    check_col.data.top_left -= min;
    check_col.data.bot_left -= min;
    check_col.data.top_right -= min;

    for (i = 0; i < ARRAY_COUNT(mCoBG_hole_data); i++) {
        if (attr == (check_col.raw - mCoBG_hole_data[i].raw)) {
            return i;
        }
    }

    return -1;
}

extern int mCoBG_GetHoleNumber(xyz_t pos) {
    mCoBG_Collision_u* col = mFI_GetUnitCol(pos);

    return mCoBG_GetHoleNumber_ClData(col);
}

extern int mCoBG_BnumUnum2HoleNumber(int bx, int bz, int b_ux, int b_uz) {
    int ux = bx * UT_X_NUM + b_ux;
    int uz = bz * UT_Z_NUM + b_uz;
    mCoBG_Collision_u* col = mFI_UtNum2UtCol(ux, uz);

    if (col != NULL) {
        return mCoBG_GetHoleNumber_ClData(col);
    } else {
        return -1;
    }
}

extern int mCoBG_CheckHole_OrgAttr(u32 attr) {
    switch (attr) {
        case mCoBG_ATTRIBUTE_HOLE:
        case mCoBG_ATTRIBUTE_GRASS0:
        case mCoBG_ATTRIBUTE_GRASS1:
        case mCoBG_ATTRIBUTE_GRASS2:
        case mCoBG_ATTRIBUTE_SOIL0:
        case mCoBG_ATTRIBUTE_SOIL1:
        case mCoBG_ATTRIBUTE_SOIL2:
        case mCoBG_ATTRIBUTE_SAND:
        case mCoBG_ATTRIBUTE_25:
        case mCoBG_ATTRIBUTE_26:
        case mCoBG_ATTRIBUTE_36:
        case mCoBG_ATTRIBUTE_43:
        case mCoBG_ATTRIBUTE_44:
        case mCoBG_ATTRIBUTE_45:
        case mCoBG_ATTRIBUTE_46:
        case mCoBG_ATTRIBUTE_59:
        case mCoBG_ATTRIBUTE_60:
        case mCoBG_ATTRIBUTE_61:
        case mCoBG_ATTRIBUTE_62:
            return TRUE;
        default:
            return FALSE;
    }
}

extern int mCoBG_CheckSandUt_ForFish(xyz_t* pos) {
    mCoBG_Collision_u* col = mFI_GetUnitCol(*pos);
    u32 attr = col->data.unit_attribute;

    switch (attr) {
        case mCoBG_ATTRIBUTE_HOLE:
        case mCoBG_ATTRIBUTE_SAND:
        case mCoBG_ATTRIBUTE_25:
        case mCoBG_ATTRIBUTE_26:
        case mCoBG_ATTRIBUTE_36:
        case mCoBG_ATTRIBUTE_37:
        case mCoBG_ATTRIBUTE_38:
            return TRUE;
        default:
            return FALSE;
    }
}

extern int mCoBG_CheckSandHole_ClData(mCoBG_Collision_u* col) {
    u32 attr = col->data.unit_attribute;

    switch (attr) {
        case mCoBG_ATTRIBUTE_HOLE:
        case mCoBG_ATTRIBUTE_SAND:
        case mCoBG_ATTRIBUTE_25:
        case mCoBG_ATTRIBUTE_26:
        case mCoBG_ATTRIBUTE_36:
            return TRUE;
        default:
            return FALSE;
    }
}

// @unused, @fabricated
extern int mCoBG_BnumUnum2SandHole(int bx, int bz, int b_ux, int b_uz) {
    int ux = bx * UT_X_NUM + b_ux;
    int uz = bz * UT_Z_NUM + b_uz;
    mCoBG_Collision_u* col = mFI_UtNum2UtCol(ux, uz);

    if (col != NULL) {
        return mCoBG_CheckSandHole_ClData(col);
    } else {
        return FALSE;
    }
}

extern int mCoBG_CheckHole(xyz_t pos) {
    mCoBG_Collision_u* col = mFI_GetUnitCol(pos);
    u32 attr = col->data.unit_attribute;

    if (mCoBG_CheckHole_OrgAttr(attr)) {
        return TRUE;
    }

    if (attr == mCoBG_ATTRIBUTE_63) {
        static const xyz_t area_offset_table[mCoBG_AREA_NUM] = {
            { 10.0f, 0.0f, 0.0f },
            { -10.0f, 0.0f, 0.0f },
            { 0.0f, 0.0f, 10.0f },
            { 0.0f, 0.0f, -10.0f },
        };

        int i;
        xyz_t center = { 0.0f, 0.0f, 0.0f };
        xyz_t check = { 0.0f, 0.0f, 0.0f };

        // @enhancement - why are we setting the values to 0.0f when they're already initialized to 0?
        center.x = 0.0f;
        center.y = 0.0f;
        center.z = 0.0f;
        if (mFI_Wpos2UtCenterWpos(&center, pos)) {
            center.y = 0.0f;
            for (i = 0; i < mCoBG_AREA_NUM; i++) {
                check.x = center.x + area_offset_table[i].x;
                check.y = center.y + area_offset_table[i].y;
                check.z = center.z + area_offset_table[i].z;
                if (mCoBG_CheckHole_OrgAttr(mCoBG_Wpos2Attribute(check, NULL)) == FALSE) {
                    return FALSE;
                }
            }

            return TRUE;
        }
    }

    return FALSE;
}

extern int mCoBG_CheckAirSwing(xyz_t pos) {
    mCoBG_Collision_u* col = mFI_GetUnitCol(pos);
    u32 attr = col->data.unit_attribute;

    if (attr >= mCoBG_ATTRIBUTE_WAVE && attr <= mCoBG_ATTRIBUTE_RIVER_NE) {
        return TRUE;
    }

    if (attr == mCoBG_ATTRIBUTE_SEA || attr == mCoBG_ATTRIBUTE_37 || attr == mCoBG_ATTRIBUTE_38) {
        return TRUE;
    }

    if (attr >= mCoBG_ATTRIBUTE_39 && attr <= mCoBG_ATTRIBUTE_62) {
        if (attr >= mCoBG_ATTRIBUTE_47 && attr <= mCoBG_ATTRIBUTE_54) {
            return FALSE;
        } else {
            return TRUE;
        }
    }

    return FALSE;
}

extern int mCoBG_CheckGrassX_ClData(mCoBG_Collision_u* col) {
    u32 attr = col->data.unit_attribute;

    switch (attr) {
        case mCoBG_ATTRIBUTE_GRASS3:
        case mCoBG_ATTRIBUTE_47:
        case mCoBG_ATTRIBUTE_48:
        case mCoBG_ATTRIBUTE_49:
        case mCoBG_ATTRIBUTE_50:
        case mCoBG_ATTRIBUTE_51:
        case mCoBG_ATTRIBUTE_52:
        case mCoBG_ATTRIBUTE_53:
        case mCoBG_ATTRIBUTE_54:
            return TRUE;
        default:
            return FALSE;
    }
}

extern int mCoBG_CheckGrassX(const xyz_t* pos) {
    mCoBG_Collision_u* col = mFI_GetUnitCol(*pos);

    return mCoBG_CheckGrassX_ClData(col);
}

extern int mCoBG_CheckWave_ClData(mCoBG_Collision_u* col) {
    u32 attr = col->data.unit_attribute;

    switch (attr) {
        case mCoBG_ATTRIBUTE_WAVE:
        case mCoBG_ATTRIBUTE_25:
        case mCoBG_ATTRIBUTE_26:
        case mCoBG_ATTRIBUTE_36:
        case mCoBG_ATTRIBUTE_37:
        case mCoBG_ATTRIBUTE_38:
            return TRUE;
        default:
            return FALSE;
    }
}

extern int mCoBG_CheckWave(const xyz_t* pos) {
    mCoBG_Collision_u* col = mFI_GetUnitCol(*pos);

    return mCoBG_CheckWave_ClData(col);
}

extern int mCoBG_CheckAcceptDesignSign(const xyz_t* pos_p) {
    int ux;
    int uz;
    int bx;
    int bz;

    if (mFI_Wpos2BkandUtNuminBlock(&bx, &bz, &ux, &uz, *pos_p)) {
        mRF_gate_c* gate;
        int gate_count = 0;
        u8 block_type = mFI_BkNum2BlockType(bx, bz);
        int i;
        int j;
        int ut = uz * UT_X_NUM + ux;
        
        // Check location in player house block
        if (bx == 3 && bz == 2) {
            // check bottom center units
            if (
                // clang-format off
                ut == UNITXZ_2_UNIT(6, 14) || ut == UNITXZ_2_UNIT(7, 14) || ut == UNITXZ_2_UNIT(8, 14) || ut == UNITXZ_2_UNIT(9, 14) ||
                ut == UNITXZ_2_UNIT(6, 15) || ut == UNITXZ_2_UNIT(7, 15) || ut == UNITXZ_2_UNIT(8, 15) || ut == UNITXZ_2_UNIT(9, 15)
                // clang-format on
            ) {
                return FALSE;
            }
        } else if (bx == 3 && bz == 3) { // acre directly below player house block
            // check top center units
            if (
                // clang-format off
                ut == UNITXZ_2_UNIT(7, 0) || ut == UNITXZ_2_UNIT(8, 0) ||
                ut == UNITXZ_2_UNIT(7, 1) || ut == UNITXZ_2_UNIT(8, 1) ||
                ut == UNITXZ_2_UNIT(7, 2) || ut == UNITXZ_2_UNIT(8, 2)
                // clang-format on
            ) {
                return FALSE;
            }
        }

        for (i = 0; i < mRF_DIRECT_NUM; i++) {
            gate = mRF_BlockTypeDirect2GateData(&gate_count, block_type, i);
            if (gate != NULL) {
                for (j = 0; j < gate_count; j++) {
                    if (ut == gate[j].ut0 || ut == gate[j].ut1) {
                        return FALSE;
                    }
                }
            }
        }

        if (mCoBG_CheckGrassX(pos_p) == FALSE && mCoBG_CheckWave(pos_p) == FALSE) {
            return TRUE;
        }
    }

    return FALSE;
}

extern f32 mCoBG_GetBgHeightGapBetweenNowDefault(xyz_t pos) {
    return mCoBG_Wpos2BgUtCenterHeight_AddColumn(pos) - mCoBG_GetBgY_OnlyCenter_FromWpos2(pos, 0.0f);
}

extern int mCoBG_ExistHeightGap_KeepAndNow(xyz_t pos) {
    if ((int)mCoBG_GetBgHeightGapBetweenNowDefault(pos) != 0) {
        return TRUE;
    }

    return FALSE;
}

extern int mCoBG_SearchWaterLimitDistN(xyz_t* water_pos, xyz_t pos, s16 angle, f32 dist_limit, int divide) {
    static xyz_t pos0 = { 0.0f, 0.0f, 0.0f };
    static xyz_t offset[] = {
        { 12.0f, 0.0f, 12.0f },
        { 12.0f, 0.0f, -12.0f },
        { -12.0f, 0.0f, -12.0f },
        { -12.0f, 0.0f, 12.0f },
    };

    *water_pos = pos0;
    pos.y = 0.0f;
    if (divide >= 1) {
        f32 divide_dist = dist_limit / (f32)divide;
        xyz_t vec = { 0.0f, 0.0f, 1.0f };
        xyz_t search;
        int i;
        u32 attr;

        sMath_RotateY(&vec, SHORT2RAD_ANGLE2(angle));
        for (i = 0; i <= divide; i++) {
            search.x = pos.x + vec.x * (divide_dist * i);
            search.y = pos.y + vec.y * (divide_dist * i);
            search.z = pos.z + vec.z * (divide_dist * i);
            attr = mCoBG_Wpos2Attribute(search, NULL);
            if (mCoBG_CheckWaterAttribute(attr)) {
                xyz_t search2;
                int j;
                int water_count = 0;

                for (j = 0; j < ARRAY_COUNT(offset); j++) {
                    search2 = search;
                    search2.x += offset[j].x;
                    search2.z += offset[j].z;
                    attr = mCoBG_Wpos2Attribute(search2, NULL);
                    if (mCoBG_CheckWaterAttribute(attr) == FALSE) {
                        break;
                    }

                    water_count++;
                }

                if (water_count == ARRAY_COUNT(offset)) {
                    *water_pos = search;
                    water_pos->y = mCoBG_GetWaterHeight_File(search, __FILE__, 1310);
                    return TRUE;
                }

            }
        }

        return FALSE;
    }

    return FALSE;
}

// @unused, @fabricated
extern int mCoBG_CheckRoughPathInRoom(const xyz_t* pos) {
    static xyz_t pos_offset_table[] = {
        { 0.0f, 0.0f, -mFI_UT_WORLDSIZE_Z_F },
        { -mFI_UT_WORLDSIZE_X_F, 0.0f, 0.0f },
        { 0.0f, 0.0f, mFI_UT_WORLDSIZE_Z_F },
        { mFI_UT_WORLDSIZE_X_F, 0.0f, 0.0f },
    };

    f32 y = mCoBG_GetBgY_AngleS_FromWpos(NULL, *pos, 0.0f);
    f32 check_y;
    xyz_t check_pos;
    int i;
    int p = 0;

    for (i = 0; i < 4; i++) {
        check_pos.x = pos->x + pos_offset_table[i].x;
        check_pos.z = pos->z + pos_offset_table[i].z;
        check_y = mCoBG_GetBgY_AngleS_FromWpos(NULL, check_pos, 0.0f);
        if (check_y <= y) {
            p |= (1 << i);
        }
    }

    return p;
}

// GAFU01 checks for sea wave attributes
extern f32 mCoBG_GetBalloonGroundY(const xyz_t* pos) {
    mCoBG_UnitInfo_c ut_info;
    s_xyz normal_ground_angle;
    f32 normal_y;
    u32 attr;
    int bx;
    int bz;

    attr = mCoBG_Wpos2Attribute(*pos, NULL);
    if (mFI_Wpos2BlockNum(&bx, &bz, *pos)) {
        u32 block_kind = mFI_BkNum2BlockKind(bx, bz);

        if ((block_kind & mRF_BLOCKKIND_MARINE) != 0) {
            if (mCoBG_CheckWaterAttribute(attr) == TRUE || attr == mCoBG_ATTRIBUTE_WAVE || attr == mCoBG_ATTRIBUTE_SAND ||
                attr == mCoBG_ATTRIBUTE_SEA || attr == mCoBG_ATTRIBUTE_37 || attr == mCoBG_ATTRIBUTE_38) {
                return mFI_UNIT_BASE_SIZE_F;
            }
        }
    }

    mCoBG_Wpos2UnitInfo(&ut_info, *pos);
    normal_y = mCoBG_GetBGHeight_Normal(&normal_ground_angle, &ut_info);
    if (mCoBG_CheckWaterAttribute(attr)) {
        return mFI_UNIT_BASE_SIZE_F + normal_y;
    }

    return normal_y;
}

extern int mCoBG_CheckAttribute_BallRolling(s16* angle, const xyz_t* pos) {
    u32 attr = mCoBG_Wpos2BgAttribute_Original(*pos);

    angle[0] = -1;
    angle[1] = -1;

    if (attr >= mCoBG_ATTRIBUTE_27 && attr <= mCoBG_ATTRIBUTE_62) {
        int i;
        int idx = attr - mCoBG_ATTRIBUTE_27;
        int idx2;

        for (i = 0; i < 2; i++) {
            idx2 = mCoBG_forbid_vector_idx[idx][i];

            if (idx2 != -1) {
                angle[i] = mCoBG_make_vector_table[idx2 & 7].norm_angle + DEG2SHORT_ANGLE2(180.0f);
            }
        }
    }

    if (angle[0] != -1 || angle[1] != -1) {
        return TRUE;
    }

    return FALSE;
}

static f32 mCoBG_CheckBallRollingAreaRate(const xyz_t* pos, const xyz_t* start_pos, const xyz_t* end_pos) {
    f32 cross[2];
    f32 end[2];
    f32 start[2];
    f32 point[2];

    end[0] = end_pos->x;
    end[1] = end_pos->z;
    start[0] = start_pos->x;
    start[1] = start_pos->z;
    point[0] = pos->x;
    point[1] = pos->z;
    
    if (mCoBG_GetCrossLineAndPerpendicular(cross, end, start, point)) {
        f32 dist_start_end_x = end[0] - start[0];
        f32 dist_start_end_z = end[1] - start[1];
        f32 dist_start_end = sqrtf(SQ(dist_start_end_x) + SQ(dist_start_end_z));
        f32 dist_start_cross_x = cross[0] - start[0];
        f32 dist_start_cross_z = cross[1] - start[1];
        f32 dist_start_cross = sqrtf(SQ(dist_start_cross_x) + SQ(dist_start_cross_z));
        f32 rate = !F32_IS_ZERO(dist_start_end) ? dist_start_cross / dist_start_end : -1.0f;

        if (mCoBG_RangeCheckLinePoint(start, end, cross) == FALSE) {
            rate = -1.0f;
        }

        return rate;
    }

    return 1.0f;
}

extern f32 mCoBG_CheckBallRollingArea(s16 angle, const xyz_t* pos) {
    xyz_t center;

    if (angle != -1) {
        if (mFI_Wpos2UtCenterWpos(&center, *pos)) {
            xyz_t pos_in_unit;

            pos_in_unit.x = pos->x - center.x;
            pos_in_unit.y = pos->y - center.y;
            pos_in_unit.z = pos->z - center.z;

            if (angle == DEG2SHORT_ANGLE(0.0f)) {
                static xyz_t start_pos = { 0.0f, 0.0f, mFI_UT_WORLDSIZE_HALF_Z_F };
                static xyz_t end_pos = { 0.0f, 0.0f, -mFI_UT_WORLDSIZE_HALF_Z_F };

                return mCoBG_CheckBallRollingAreaRate(&pos_in_unit, &start_pos, &end_pos);
            }

            if (angle == DEG2SHORT_ANGLE(45.0f)) {
                static xyz_t start_pos = { 0.0f, 0.0f, 0.0f };
                static xyz_t end_pos = { -mFI_UT_WORLDSIZE_HALF_X_F, 0.0f, 0.0f };

                return mCoBG_CheckBallRollingAreaRate(&pos_in_unit, &start_pos, &end_pos);
            }

            if (angle == DEG2SHORT_ANGLE(90.0f)) {
                static xyz_t start_pos = { mFI_UT_WORLDSIZE_HALF_X_F, 0.0f, 0.0f };
                static xyz_t end_pos = { -mFI_UT_WORLDSIZE_HALF_X_F, 0.0f, 0.0f };

                return mCoBG_CheckBallRollingAreaRate(&pos_in_unit, &start_pos, &end_pos);
            }

            if (angle == DEG2SHORT_ANGLE(135.0f)) {
                static xyz_t start_pos = { 0.0f, 0.0f, 0.0f };
                static xyz_t end_pos = { -mFI_UT_WORLDSIZE_HALF_X_F, 0.0f, mFI_UT_WORLDSIZE_HALF_Z_F };

                return mCoBG_CheckBallRollingAreaRate(&pos_in_unit, &start_pos, &end_pos);
            }

            if (angle == DEG2SHORT_ANGLE(-180.0f)) {
                static xyz_t start_pos = { 0.0f, 0.0f, -mFI_UT_WORLDSIZE_HALF_Z_F };
                static xyz_t end_pos = { 0.0f, 0.0f, mFI_UT_WORLDSIZE_HALF_Z_F };

                return mCoBG_CheckBallRollingAreaRate(&pos_in_unit, &start_pos, &end_pos);
            }

            if (angle == DEG2SHORT_ANGLE(-135.0f)) {
                static xyz_t start_pos = { 0.0f, 0.0f, 0.0f };
                static xyz_t end_pos = { -mFI_UT_WORLDSIZE_HALF_X_F, 0.0f, -mFI_UT_WORLDSIZE_HALF_Z_F };

                return mCoBG_CheckBallRollingAreaRate(&pos_in_unit, &start_pos, &end_pos);
            }

            if (angle == DEG2SHORT_ANGLE(-90.0f)) {
                static xyz_t start_pos = { -mFI_UT_WORLDSIZE_HALF_X_F, 0.0f, 0.0f };
                static xyz_t end_pos = { mFI_UT_WORLDSIZE_HALF_X_F, 0.0f, 0.0f };

                return mCoBG_CheckBallRollingAreaRate(&pos_in_unit, &start_pos, &end_pos);
            }

            if (angle == DEG2SHORT_ANGLE(-45.0f)) {
                static xyz_t start_pos = { 0.0f, 0.0f, 0.0f };
                static xyz_t end_pos = { mFI_UT_WORLDSIZE_HALF_X_F, 0.0f, -mFI_UT_WORLDSIZE_HALF_Z_F };

                return mCoBG_CheckBallRollingAreaRate(&pos_in_unit, &start_pos, &end_pos);
            }
        }
    }

    return 1.0f;
}

extern f32 mCoBG_Wpos2GroundCheckOnly(const xyz_t* pos, f32 ground_dist) {
    f32 ground_y = mCoBG_GetBgY_AngleS_FromWpos(NULL, *pos, ground_dist);

    if (pos->y < ground_y) {
        return ground_y - pos->y;
    }

    return 0.0f;
}

extern int mCoBG_ExistHeightGap_KeepAndNow_Detail(xyz_t pos) {
    mCoBG_UnitInfo_c ut_info;
    f32 center_height;

    center_height = mCoBG_Wpos2BgUtCenterHeight_AddColumn(pos);
    mCoBG_Wpos2UnitInfo(&ut_info, pos);

    if (ut_info.attribute >= mCoBG_ATTRIBUTE_27 && ut_info.attribute <= mCoBG_ATTRIBUTE_31) {
        return FALSE;
    }

    if (mCoBG_ExistHeightGap_KeepAndNow(pos) == FALSE) {
        return FALSE;
    }

    if (ut_info.slate_flag) {
        xyz_t center;
        xyz_t vec;
        f32 corner0;
        f32 corner1;

        mFI_Wpos2UtCenterWpos(&center, pos);
        xyz_t_sub(&pos, &center, &vec);

        corner0 = (vec.x - vec.z >= 0.0f) ? ut_info.rightUp_offset : ut_info.leftDown_offset;
        corner1 = (vec.x + vec.z >= 0.0f) ? ut_info.rightDown_offset : ut_info.leftUp_offset;
        if (corner0 < center_height || corner1 < center_height) {
            return FALSE;
        }

    }

    return TRUE;
}

extern int mCoBG_Wpos2CheckSlateCol(const xyz_t* pos, int check_attr) {
    mCoBG_Collision_u* col = mFI_GetUnitCol(*pos);
    u32 attr = col->data.unit_attribute;

    if (col->data.slate_flag) {
        return TRUE;
    }

    if (check_attr) {
        switch (attr) {
            case mCoBG_ATTRIBUTE_27:
            case mCoBG_ATTRIBUTE_28:
            case mCoBG_ATTRIBUTE_29:
            case mCoBG_ATTRIBUTE_30:
            case mCoBG_ATTRIBUTE_37:
            case mCoBG_ATTRIBUTE_38:
            case mCoBG_ATTRIBUTE_39:
            case mCoBG_ATTRIBUTE_40:
            case mCoBG_ATTRIBUTE_41:
            case mCoBG_ATTRIBUTE_42:
            case mCoBG_ATTRIBUTE_55:
            case mCoBG_ATTRIBUTE_56:
            case mCoBG_ATTRIBUTE_57:
            case mCoBG_ATTRIBUTE_58:
                return TRUE;
            default:
                return FALSE;
        }
    }
    return FALSE;
}

extern int mCoBG_WoodSoundEffect(const xyz_t* pos) {
    u32 attr = mCoBG_Wpos2BgAttribute_Original(*pos);

    switch (attr) {
        case mCoBG_ATTRIBUTE_WOOD:
        case mCoBG_ATTRIBUTE_27:
        case mCoBG_ATTRIBUTE_28:
        case mCoBG_ATTRIBUTE_29:
        case mCoBG_ATTRIBUTE_30:
        case mCoBG_ATTRIBUTE_31:
            return TRUE;
        default:
            return FALSE;
    }
}

extern int mCoBG_CheckCliffAttr(u32 attr) {
    if (attr >= mCoBG_ATTRIBUTE_47 && attr <= mCoBG_ATTRIBUTE_54) {
        return TRUE;
    }

    if (attr == mCoBG_ATTRIBUTE_55 || attr == mCoBG_ATTRIBUTE_56 || attr == mCoBG_ATTRIBUTE_57 || attr == mCoBG_ATTRIBUTE_58) {
        return TRUE;
    }

    return FALSE;
}

extern f32 mCoBG_GetShadowBgY_AngleS_FromWpos(s_xyz* ground_angle, xyz_t pos, f32 ground_dist) {
    mCoBG_UnitInfo_c ut_info;
    s_xyz angle0 = { 0, 0, 0 };

    mCoBG_Wpos2UnitInfo(&ut_info, pos);
    if (ground_angle != NULL) {
        *ground_angle = angle0;
    }

    if (ut_info.collision->data.center != mFI_UtNum2UtKeepH(ut_info.ut_x, ut_info.ut_z)) {
        if (ut_info.attribute >= mCoBG_ATTRIBUTE_27 && ut_info.attribute <= mCoBG_ATTRIBUTE_31) {
            return mCoBG_GetBGHeight_Normal(ground_angle, &ut_info) - ground_dist;
        }

        return mFI_UtNum2UtKeepH(ut_info.ut_x, ut_info.ut_z) * 10.0f + mFI_UtNum2BaseHeight(ut_info.ut_x, ut_info.ut_z) - ground_dist;
    }

    return mCoBG_GetBGHeight_Normal(ground_angle, &ut_info) - ground_dist;
}

extern int mCoBG_CheckUtFlat(const xyz_t* pos) {
    mCoBG_Collision_u* col = mFI_GetUnitCol(*pos);

    // clang-format off
    if (
        col->data.center == col->data.top_left &&
        col->data.center == col->data.bot_left &&
        col->data.center == col->data.bot_right &&
        col->data.center == col->data.top_right
    ) {
        return TRUE;
    }

    return FALSE;
}

extern int mCoBG_Height2GetLayer(f32 height) {
    if (height < 100.0f) {
        return mCoBG_LAYER0;
    } else {
        if (mRF_CheckFieldStep3()) {
            if (height < 220.0f) {
                return mCoBG_LAYER1;
            } else {
                return mCoBG_LAYER2;
            }
        } else {
            return mCoBG_LAYER1;
        }
    }
}

extern int mCoBG_GetLayer(const xyz_t* pos) {
    return mCoBG_Height2GetLayer(mCoBG_GetBgY_OnlyCenter_FromWpos2(*pos, 0.0f));
}

// GAFU01 renames mCoBG_GetBgY_AngleS_FromWpos2 to this
extern f32 mCoBG_Wpos2BgHeight_AngleSXXX(s_xyz* ground_angle, xyz_t pos, f32 ground_dist) {
    mCoBG_UnitInfo_c ut_info;
    s_xyz normal_ground_angle;
    f32 normal_y;
    f32 column_y;
    static s_xyz ground_angle0 = { 0, 0, 0 };
    f32 t0;
    f32 t1;
    f32 ret;

    if (ground_angle != NULL) {
        *ground_angle = ground_angle0;
    }

    mCoBG_Wpos2UnitInfo(&ut_info, pos);
    normal_y = mCoBG_GetBGHeight_Normal(&normal_ground_angle, &ut_info);
    column_y = mCoBG_GetBGHeight_Column(&pos, &ut_info);
    
    if (ground_angle != NULL && normal_y >= column_y && normal_y >= -100.0f) {
        *ground_angle = normal_ground_angle;
        return normal_y - ground_dist;
    }

    t0 = MAX(normal_y, -100.0f);
    t1 = MAX(normal_y, column_y);
    if (t1 > t0) {
        ret = MAX(normal_y, column_y);
    } else {
        ret = MAX(normal_y, -100.0f);
    }

    return ret - ground_dist;
}



// GAFU01 adds checks for sea attributes when checking from bridge tiles
extern f32 mCoBG_GetWaterHeight_File(xyz_t pos, char* file, int line) {
    u32 attr;
    int ux;
    int uz;
    mCoBG_Collision_u* col;
    xyz_t mod_pos = pos;

    mFI_Wpos2UtNum(&ux, &uz, pos);
    col = mFI_UtNum2UtCol(ux, uz);
    attr = col->data.unit_attribute;

    if (attr == mCoBG_ATTRIBUTE_SEA || attr == mCoBG_ATTRIBUTE_37 || attr == mCoBG_ATTRIBUTE_38) {
        return 20.0f;
    }

    if (attr >= mCoBG_ATTRIBUTE_WATER && attr <= mCoBG_ATTRIBUTE_RIVER_NE) {
        return 20.0f + mCoBG_Wpos2BgHeight_AngleSXXX(NULL, pos, 0.0f);
    }

    if (attr >= mCoBG_ATTRIBUTE_27 && attr <= mCoBG_ATTRIBUTE_35) {
        int idx = attr - mCoBG_ATTRIBUTE_27;
        int search = mCoBG_bridge_search_water[idx];
        u32 new_attr;
        int i;

        for (i = 0; i < mSc_DIRECT_NUM; i++) {
            if ((search & (1 << i)) != 0) {
                int ux;
                int uz;

                mCoBG_PlussDirectOffset(&mod_pos, pos, i);
                mFI_Wpos2UtNum(&ux, &uz, mod_pos);
                new_attr = mFI_UtNum2UtCol(ux, uz)->data.unit_attribute;

                if (new_attr == mCoBG_ATTRIBUTE_SEA || new_attr == mCoBG_ATTRIBUTE_37 || new_attr == mCoBG_ATTRIBUTE_38) {
                    return 20.0f;
                }

                if (new_attr >= mCoBG_ATTRIBUTE_WATER && new_attr <= mCoBG_ATTRIBUTE_RIVER_NE) {
                    return 20.0f + mCoBG_Wpos2BgHeight_AngleSXXX(NULL, mod_pos, 0.0f);
                }
            }
        }
    } else if (attr >= mCoBG_ATTRIBUTE_39 && attr <= mCoBG_ATTRIBUTE_42) {
        u32 attr2 = mCoBG_Wpos2Attribute(pos, NULL);

        if (attr2 >= mCoBG_ATTRIBUTE_WATER && attr2 <= mCoBG_ATTRIBUTE_RIVER_NE) {
            int i;
            u32 new_attr;
            xyz_t new_pos;
            int idx = attr - mCoBG_ATTRIBUTE_39;
            int search = mCoBG_grass3_search_water[idx];

            for (i = 0; i < mSc_DIRECT_NUM; i++) {
                if ((search & (1 << i)) != 0) {
                    int ux;
                    int uz;

                    mCoBG_PlussDirectOffset(&new_pos, pos, i);
                    mFI_Wpos2UtNum(&ux, &uz, new_pos);
                    new_attr = mFI_UtNum2UtCol(ux, uz)->data.unit_attribute;

                    if (new_attr >= mCoBG_ATTRIBUTE_WATER && new_attr <= mCoBG_ATTRIBUTE_RIVER_NE) {
                        return 20.0f + mCoBG_Wpos2BgHeight_AngleSXXX(NULL, new_pos, 0.0f);
                    }
                }
            }
        }
    }

    return -100.0f;
}

// GAFU01 checks two missing sea attributes
extern int mCoBG_CheckWaterAttribute(u32 attr) {
    if (attr == mCoBG_ATTRIBUTE_SEA || attr == mCoBG_ATTRIBUTE_37 || attr == mCoBG_ATTRIBUTE_38) {
        return TRUE;
    }

    if (attr >= mCoBG_ATTRIBUTE_WATER && attr <= mCoBG_ATTRIBUTE_RIVER_NE) {
        return TRUE;
    }

    return FALSE;
}

extern int mCoBG_CheckWaterAttribute_OutOfSea(u32 attr) {
    return (attr >= mCoBG_ATTRIBUTE_WATER && attr <= mCoBG_ATTRIBUTE_RIVER_NE) != FALSE;
}

static f32 mCoBG_wave_cos = 0.0f;

extern void mCoBG_WaveCos2BgCheck(f32 value) {
    mCoBG_wave_cos = value;
}

extern f32 mCoBG_WaveCos(void) {
    return mCoBG_wave_cos;
}

extern int mCoBG_GetWaterFlow(xyz_t* flow, u32 attr) {
    static xyz_t flow_data[] = {
        {0.0f, 0.0f, 0.0f},
        {0.0f, -5.0f, 0.0f},
        {0.0f, 0.0f, -0.5f},
        {-0.35355338f, 0.0f, -0.35355338f},
        {-0.5f, 0.0f, 0.0f},
        {-0.35355338f, 0.0f, 0.35355338f},
        {0.0f, 0.0f, 0.5f},
        {0.35355338f, 0.0f, 0.35355338f},
        {0.5f, 0.0f, 0.0f},
        {0.35355338f, 0.0f, -0.35355338f},
    };

    if (attr == mCoBG_ATTRIBUTE_SEA) {
        static const xyz_t sea_flow = { 0.0f, 0.0f, -1.0f };

        *flow = sea_flow;
        return TRUE;
    }

    if (mCoBG_CheckWaterAttribute(attr)) {
        int idx = attr - mCoBG_ATTRIBUTE_WATER;

        *flow = flow_data[idx];
        return TRUE;
    }

    *flow = flow_data[0];
    return FALSE;
}

extern int mCoBG_CheckWaveAttr(u32 attr) {
    switch (attr) {
        case mCoBG_ATTRIBUTE_WAVE:
        case mCoBG_ATTRIBUTE_36:
        case mCoBG_ATTRIBUTE_25:
        case mCoBG_ATTRIBUTE_26:
            return TRUE;
        default:
            return FALSE;
    }
}

// @unused, @fabricated
extern int mCoBG_CheckSand2Sea(xyz_t* pos) {
    u32 attr = mCoBG_Wpos2BgAttribute_Original(*pos);

    if (attr == mCoBG_ATTRIBUTE_SEA || mCoBG_CheckWaveAttr(attr)) {
        return TRUE;
    }

    return FALSE;
}


static u32 mCoBG_OffsetInRule(int ofs) {
    if (ofs > 31) {
        return 31;
    }

    return CLAMP(ofs, 0, ofs);
}

static void mCoBG_SetBestBgY(mCoBG_Collision_u* col, s16* change_ofs) {
    u32 max = mCoBG_GetMaxOffset(col->data.center, col->data.top_left, col->data.bot_left, col->data.bot_right, col->data.top_right);
    u32 min = mCoBG_GetMinOffset(col->data.center, col->data.top_left, col->data.bot_left, col->data.bot_right, col->data.top_right);
}

static void mCoBG_TidyChangeOffset(s16* change_ofs, mCoBG_Collision_u* col) {
    if (
        // clang-format off
        col->data.center + *change_ofs > 31 ||
        col->data.top_left + *change_ofs > 31 ||
        col->data.bot_left + *change_ofs > 31 ||
        col->data.bot_right + *change_ofs > 31 ||
        col->data.top_right + *change_ofs > 31 ||
        col->data.center + *change_ofs < 0 ||
        col->data.top_left + *change_ofs < 0 ||
        col->data.bot_left + *change_ofs < 0 ||
        col->data.bot_right + *change_ofs < 0 ||
        col->data.top_right + *change_ofs < 0
        // clang-format on
    ) {
        mCoBG_SetBestBgY(col, change_ofs);
    }
}

// @unused, @fabricated
extern void mCoBG_Ut2SetPlussOffset(int ux, int uz, s16 change_ofs, s16 attr) {
    xyz_t pos = { 0.0f, 0.0f, 0.0f };

    if (mFI_UtNum2CenterWpos(&pos, ux, uz)) {
        mCoBG_SetPlussOffset(pos, change_ofs, attr);
    }
}

extern void mCoBG_SetPlussOffset(xyz_t wpos, s16 change_ofs, s16 attr) {
    int ux;
    int uz;

    if (mFI_Wpos2UtNum(&ux, &uz, wpos)) {
        mCoBG_Collision_u* col = mFI_UtNum2UtCol(ux, uz);
        u8 keep_h = mFI_UtNum2UtKeepH(ux, uz);

        if (keep_h == col->data.center) {
            mCoBG_TidyChangeOffset(&change_ofs, col);
        } else {
            u32 gap = keep_h - col->data.center;

            col->data.center = (u8)keep_h;
            col->data.top_left += gap;
            col->data.bot_left += gap;
            col->data.bot_right += gap;
            col->data.top_right += gap;
            mCoBG_TidyChangeOffset(&change_ofs, col);
        }

        col->data.center += change_ofs;
        col->data.bot_left += change_ofs;
        col->data.top_left += change_ofs;
        col->data.top_right += change_ofs;
        col->data.bot_right += change_ofs;

        if (attr != mCoBG_ATTRIBUTE_NONE) {
            col->data.unit_attribute = (s16)attr;
        }

    }
}

extern void mCoBG_SetAttribute(xyz_t pos, s16 attr) {
    mCoBG_Collision_u* col;
    int ux;
    int uz;

    if (mFI_Wpos2UtNum(&ux, &uz, pos)) {
        col = mFI_UtNum2UtCol(ux, uz);
        if (attr != mCoBG_ATTRIBUTE_NONE) {
            col->data.unit_attribute = (s16)attr;
        }
    }
}

extern void mCoBG_Ut2SetPluss5PointOffset_file(int ux, int uz, mCoBG_OffsetTable_c ofs_data, char* file, int line) {
    xyz_t pos = { 0.0f, 0.0f, 0.0f };

    if (mFI_UtNum2CenterWpos(&pos, ux, uz)) {
        mCoBG_SetPluss5PointOffset_file(pos, ofs_data, file, line);
    }
}

extern void mCoBG_SetPluss5PointOffset_file(xyz_t pos, mCoBG_OffsetTable_c ofs_data, char* file, int line) {
    int ux;
    int uz;

    if (mFI_Wpos2UtNum(&ux, &uz, pos)) {
        u8 keep_h = mFI_UtNum2UtKeepH(ux, uz);
        mCoBG_Collision_u* col = mFI_UtNum2UtCol(ux, uz);

        if (
            // clang-format off
            col->data.center == col->data.top_left &&
            col->data.center == col->data.bot_left &&
            col->data.center == col->data.bot_right &&
            col->data.center == col->data.top_right
            // clang-format on
        ) {
            col->data.center = mCoBG_OffsetInRule(keep_h + ofs_data.centerRight_offset);
            col->data.top_left = mCoBG_OffsetInRule(keep_h + ofs_data.leftUp_offset);
            col->data.bot_left = mCoBG_OffsetInRule(keep_h + ofs_data.leftDown_offset);
            col->data.bot_right = mCoBG_OffsetInRule(keep_h + ofs_data.rightDown_offset);
            col->data.top_right = mCoBG_OffsetInRule(keep_h + ofs_data.rightUp_offset);
            col->data.slate_flag = (s8)ofs_data.shape;

            if (ofs_data.unit_attribute != mCoBG_ATTRIBUTE_NONE) {
                col->data.unit_attribute = ofs_data.unit_attribute;
            }
        } else if (
            // clang-format off
            ofs_data.centerRight_offset == 0 &&
            ofs_data.leftUp_offset == 0 &&
            ofs_data.leftDown_offset == 0 &&
            ofs_data.rightDown_offset == 0 &&
            ofs_data.rightUp_offset == 0
            // clang-format on
        ) {
            if (col->data.slate_flag) {
                col->data.center = keep_h;
                col->data.top_left = keep_h;
                col->data.bot_left = keep_h;
                col->data.bot_right = keep_h;
                col->data.top_right = keep_h;
                col->data.slate_flag = FALSE;
            } else {
                col->data.center = keep_h;
                col->data.top_left = keep_h;
                col->data.bot_left = keep_h;
                col->data.bot_right = keep_h;
                col->data.top_right = keep_h;
            }

            if (ofs_data.unit_attribute != mCoBG_ATTRIBUTE_NONE) {
                col->data.unit_attribute = ofs_data.unit_attribute;
            }
        }
    }
}

typedef struct {
    u8 src;
    u8 dst;
} mCoBG_change_poor_c;

extern int mCoBG_Change2PoorAttr(mCoBG_Collision_u* col) {
    static mCoBG_change_poor_c change_data[] = {
        { mCoBG_ATTRIBUTE_GRASS0, mCoBG_ATTRIBUTE_GRASS2 },
        { mCoBG_ATTRIBUTE_GRASS1, mCoBG_ATTRIBUTE_GRASS2 },
        { mCoBG_ATTRIBUTE_SOIL0, mCoBG_ATTRIBUTE_SOIL2 },
        { mCoBG_ATTRIBUTE_SOIL1, mCoBG_ATTRIBUTE_SOIL2 },
    };
    const u8 attr = col->data.unit_attribute;
    int i;

    for (i = 0; i < ARRAY_COUNT(change_data); i++) {
        if (attr == change_data[i].src) {
            col->data.unit_attribute = change_data[i].dst;
            return TRUE;
        }
    }

    return FALSE;
}

extern void mCoBG_Ut2SetDefaultOffset(int ux, int uz) {
    static mCoBG_OffsetTable_c offset_data = { mCoBG_ATTRIBUTE_NONE, 0, 0, 0, 0, 0, FALSE };

    mCoBG_Ut2SetPluss5PointOffset_file(ux, uz, offset_data, __FILE__, 2724);
}

int mCoBG_block_bgcheck_mode = mCoBG_BLOCK_BGCHECK_MODE_NORMAL;

extern void mCoBG_InitBlockBgCheckMode(void) {
    mCoBG_block_bgcheck_mode = mCoBG_BLOCK_BGCHECK_MODE_NORMAL;
}

extern int mCoBG_ChangeBlockBgCheckMode(int mode) {
    mCoBG_block_bgcheck_mode = mode & 1;
    return mCoBG_block_bgcheck_mode;
}

extern int mCoBG_GetBlockBgCheckMode(void) {
    return mCoBG_block_bgcheck_mode & 1;
}

extern xyz_t mCoBG_UniqueWallCheck(ACTOR* actorx, f32 range, f32 y_ofs) {
    int bx;
    int bz;
    xyz_t ret = { 0.0f, 0.0f, 0.0f };

    mCoBG_InitRevpos(&l_ActorInf.rev_pos);
    mCoBG_GetCurrentCenterPosition(&l_ActorInf.center_pos, actorx);
    mCoBG_GetOldCenterPosition(&l_ActorInf.old_center_pos, actorx);
    mCoBG_GetSpeedByWpos(l_ActorInf.speed_xz0, actorx);

    if (mFI_Wpos2BlockNum(&bx, &bz, l_ActorInf.old_center_pos)) {
        xyz_t block_base = { 0.0f, 0.0f, 0.0f };

        mCoBG_SetXyz_t(&l_ActorInf.rev_pos, 0.0f, 0.0f, 0.0f);
        mFI_BkNum2WposXZ(&block_base.x, &block_base.z, bx, bz);
        if (mCoBG_GetBlockBgCheckMode() == mCoBG_BLOCK_BGCHECK_MODE_INTRO_DEMO &&
            (mFI_BkNum2BlockKind(bx, bz) & mRF_BLOCKKIND_PLAYER) != 0
        ) {
            block_base.x += mFI_UT_WORLDSIZE_X_F;
            block_base.z += mFI_UT_WORLDSIZE_Z_F;
            return mCoBG_ScopeWallCheck(actorx, &block_base, mFI_BK_WORLDSIZE_X - 2 * mFI_UT_WORLDSIZE_X, mFI_BK_WORLDSIZE_Z - 2 * mFI_UT_WORLDSIZE_Z, range, y_ofs);
        } else {
            return mCoBG_ScopeWallCheck(actorx, &block_base, mFI_BK_WORLDSIZE_X, mFI_BK_WORLDSIZE_Z, range, y_ofs);
        }
    }

    return ret;
}

// GAFU01 reworks this to check based on the actor's world position, use stack xyz_t instead of l_ActorInf.rev_pos,
// and moves carry out reverse to before the ground check.
extern xyz_t mCoBG_ScopeWallCheck(ACTOR* actorx, const xyz_t* base_pos, f32 x, f32 z, f32 range, f32 y_ofs) {
    f32 start[2];
    f32 end[2];
    s16 rev_type;
    xyz_t rev = { 0.0f, 0.0f, 0.0f };
    xyz_t rev_new;
    xyz_t xyz_t_why;

    mCoBG_InitRevpos(&l_ActorInf.rev_pos);
    mCoBG_GetCurrentCenterPosition(&l_ActorInf.center_pos, actorx);
    mCoBG_GetOldCenterPosition(&l_ActorInf.old_center_pos, actorx);
    mCoBG_GetSpeedByWpos(l_ActorInf.speed_xz0, actorx);

    if (l_ActorInf.speed_xz0[0] != 0.0f || l_ActorInf.speed_xz0[1] != 0.0f) {
        start[0] = (base_pos->x);
        start[1] = (base_pos->z);
        end[0] = start[0] + x;
        end[1] = start[1] + z;
        
        start[0] += range;
        start[1] += range;

        end[0] -= range;
        end[1] -= range;

        mCoBG_SetXyz_t(&rev_new, 0.0f, 0.0f, 0.0f);

        if (actorx->world.position.x < start[0]) {
            rev_new.x = start[0] - actorx->world.position.x;
        } else if (actorx->world.position.x > end[0]) {
            rev_new.x = end[0] - actorx->world.position.x;
        }

        if (actorx->world.position.z < start[1]) {
            rev_new.z = start[1] - actorx->world.position.z;
        } else if (actorx->world.position.z > end[1]) {
            rev_new.z = end[1] - actorx->world.position.z;
        }

        mCoBG_CarryOutReverse(actorx, rev_new, mCoBG_REVERSE_TYPE_REVERSE);
        mCoBG_GroundCheck(&l_ActorInf.rev_pos, &l_ActorInf, actorx, y_ofs, &actorx->bg_collision_check.result, NULL, FALSE);
        xyz_t_why.x = rev_new.x;
        xyz_t_why.y = l_ActorInf.rev_pos.y;
        xyz_t_why.z = rev_new.z;
        return xyz_t_why;
    }

    return rev;
}
